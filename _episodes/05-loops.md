---
title: "Getting started with loops"
teaching: 60
exercises: 30
questions:
- "How do I get run the same piece of code repeatedly?"
objectives:
- "Iterate over an array."
keypoints:
- "The `for` iterates a loop."
---

When we compute our simulation, we will need to store the new
temperature temporarily in a new array as we compute them. This will
prevent newly computed values from influencing the calculations being
performed in other cells.

```
// Current temperatures
var temperature: [0..rows + 1, 0..cols + 1] real;
// Newly computed temperatures
var temperature_new: [0..rows + 1, 0..cols + 1] real;
```
{: .code}

To compute the new temperature of an element of the array `temperature_new`,
we need to add all of the surrounding elements of the existing values
of `temperature`, and divide the result by 4. 

We need to repeat this process for all the elements of `temperature_new`.
This is called *iterating* over the elements of `temperature`.
When it comes to iterating over a given number of elements,
the **_for-loop_** is what we want to use.

The for-loop has the following general syntax: 

```
for index in iterand do
{
  // Instructions to iterate over go here
}
``` 

The *iterand* is a function or statement that expresses an iteration;
it could be the range `1..15`, for example.

*`index`* is a variable that exists only in the context of the for-loop,
and that will be taking the different values generated by the iterand.

The code flows as follows: `index` takes the first value produced by the
iterand, and keeps it until all the instructions inside the curly brackets
are executed one by one;
then, `index` takes the second value yielded by the iterand, and keeps it
until all the instructions are executed again.
This pattern is repeated until index takes all the different values
expressed by the iterand.

The following `for` loop, for example, will allow us to iterate over the
rows of `temperature_new`

~~~
for i in 1..rows do
{
  // Instruction to perform on every row go here 
}
~~~
{: .source}

For each row, we will also want to iterate over all og the columns in order
to access every single element of `temperature_new`.
This can be done with a **nested for-loop**, like this

~~~
for i in 1..rows do   
{
  for j in 1..cols do
  {
    // Instructions to perform for every column (and each row) go here
  }
}     
~~~
{: .source}

For our simulation, inside the inner loop, we can use the indices
`i` and `j` to perform the required computations as follows:

~~~
// Calculate the new temperatures (temperature_new) using the
// existing temperatures (temperature)
for i in 1..rows do
{
  for j in 1..cols do
  {
    temperature_new[i,j] = (temperature[i-1, j] +
                            temperature[i+1, j] +
                            temperature[i, j-1] +
                            temperature[i, j+1]) / 4;
  }
}     
temperature = temperature_new;
~~~
{: .source}

At the end of the outer for-loop, when all the elements in `temperature_new`
are already calculated, we update `temperature` with the values of
`temperature_new`. This way, everything is set up for the next iteration of
the main while statement.

Our full program now looks like this:
```
// Number of rows and columns in matrix 
const rows = 100;
const cols = 100;

// Number of iterations
const num_iterations = 500;

// Row and column of desired position
const x = 50;
const y = 50;

// Smallest difference in temperature that would be accepted before stopping
const min_diff = 0.0001: real;

// Print temperature every print_iterations iterations
const print_iterations = 20: int;

// This is our "plate" of temperature values
var temperature: [0..rows+1, 0..cols+1] real = 0.0;

// Set initial condition in interior
temperature[1..rows, 1..cols] = 25.0;

// Temporary storage for newly computed values
var temperature_new: [0..rows+1, 0..cols+1] real;

// Greatest difference in temperature from one iteration to another
var current_diff: real;

writeln('This simulation will consider a matrix of ', rows, ' by ', cols, ' elements.');
writeln('We will look at the temperature at the location x = ', x,
        ', y = ', y, '.');
writeln('We will run up to ', num_iterations, ' iterations, or until ',
        'the largest difference in temperature between iterations is ',
        'less than ', min_diff, '.');

writeln('\nTemperature at start is: ', temperature[x, y]);

current_diff = min_diff;

// This is the main loop of the simulation
var c = 0;
while (c < num_iterations && current_diff >= min_diff) do
{
  // Calculate the new temperatures (temperature_new) using the
  // existing temperatures (temperature)
  for i in 1..rows do
  {
    for j in 1..cols do
    {
      temperature_new[i,j] = (temperature[i-1, j] +
                              temperature[i+1, j] +
                              temperature[i, j-1] +
                              temperature[i, j+1]) / 4;
    }
  }     
  temperature = temperature_new;

  c += 1;
  if (c % print_iterations == 0)
  {
    writeln('Temperature at iteration ', c, ': ', temperature[x, y]);
  }
}
```
{: .code}

We compile and run:
```
>> chpl base_solution.chpl -o base_solution
>> ./base_solution
```
{: .input}

~~~
This simulation will consider a matrix of 100 by 100 elements.
We will look at the temperature at the location x = 50, y = 50.
We will run up to 500 iterations, or until the largest difference in temperature between iterations is less than 0.0001.

Temperature at start is: 25.0
Temperature at iteration 20: 25.0
Temperature at iteration 40: 25.0
Temperature at iteration 60: 25.0
Temperature at iteration 80: 25.0
Temperature at iteration 100: 25.0
Temperature at iteration 120: 25.0
Temperature at iteration 140: 25.0
Temperature at iteration 160: 25.0
Temperature at iteration 180: 25.0
Temperature at iteration 200: 25.0
Temperature at iteration 220: 24.9999
Temperature at iteration 240: 24.9996
Temperature at iteration 260: 24.9991
Temperature at iteration 280: 24.9981
Temperature at iteration 300: 24.9963
Temperature at iteration 320: 24.9935
Temperature at iteration 340: 24.9893
Temperature at iteration 360: 24.9833
Temperature at iteration 380: 24.9752
Temperature at iteration 400: 24.9644
Temperature at iteration 420: 24.9507
Temperature at iteration 440: 24.9337
Temperature at iteration 460: 24.913
Temperature at iteration 480: 24.8883
Temperature at iteration 500: 24.8595
~~~
{: .output}

As we can see, the temperature in the middle of the plate (position 50,50) is slowly decreasing as the plate is cooling down. 

> ## Exercise 1
> What would be the temperature at the top right corner of the plate? The border of the plate is in contact with the boundary conditions, which are set to zero, so we expect the temperature at these points to decrease faster. Modify the code to see the temperature at the top right corner.
>> ## Solution
>> To see the evolution of the temperature at the top right corner of the plate, we just need to modify `x` and `y`. This corner correspond to the first row (`x=1`) and the last column (`y=cols`) of the plate. 
>> ~~~
>> >> chpl base_solution.chpl -o base_solution
>> >> ./base_solution
>> ~~~
>> {: .input}
>> ~~~
>> This simulation will consider a matrix of 100 by 100 elements.
>> We will look at the temperature at the location x = 1, y = 1.
>> We will run up to 500 iterations, or until the largest difference in temperature between iterations is less than 0.0001.
>> 
>> Temperature at start is: 25.0
>> Temperature at iteration 20: 1.48171
>> Temperature at iteration 40: 0.767179
>> Temperature at iteration 60: 0.517628
>> Temperature at iteration 80: 0.390586
>> Temperature at iteration 100: 0.313617
>> Temperature at iteration 120: 0.26199
>> Temperature at iteration 140: 0.224958
>> Temperature at iteration 160: 0.197099
>> Temperature at iteration 180: 0.175379
>> Temperature at iteration 200: 0.157972
>> Temperature at iteration 220: 0.143708
>> Temperature at iteration 240: 0.131806
>> Temperature at iteration 260: 0.121725
>> Temperature at iteration 280: 0.113077
>> Temperature at iteration 300: 0.105576
>> Temperature at iteration 320: 0.0990081
>> Temperature at iteration 340: 0.0932096
>> Temperature at iteration 360: 0.0880528
>> Temperature at iteration 380: 0.0834366
>> Temperature at iteration 400: 0.0792804
>> Temperature at iteration 420: 0.0755185
>> Temperature at iteration 440: 0.0720975
>> Temperature at iteration 460: 0.068973
>> Temperature at iteration 480: 0.0661081
>> Temperature at iteration 500: 0.0634717
>> ~~~
>> {: .output}
> {: .solution}
{: .challenge}

> ## Exercise 2
> So far, `current_diff` has been always equal to `min_diff`,
> which means that our main while loop will always run the 500 iterations.
> So let's update `current_diff` after each iteration. Use what we have
> explored so far to write the required piece of code.
>> ## Solution
>> After each iteration of the while loop, we must
>> compare all elements of `temperature_new` and `temperature`, find the
>> greatest difference, and update `current_diff` with that value.
>> The next nested for-loops do the job:
>> ~~~
>> var this_diff = 0.0;
>>
>> // Update current_diff
>> current_diff = 0;
>> for i in 1..rows do
>> {
>>   for j in 1..cols do
>>   {
>>     this_diff = abs(temperature_new[i, j] - temperature[i, j]);
>>     if this_diff > current_diff then current_diff = this_diff;
>>   }
>> }
>> ~~~
>> {: .source}
> Make sure to put this code before the line `temperature = temperature_new;`,
> or else the computed difference will always be zero!
> {: .solution}
{: .challenge}

After the previous exercise we should have a working program to
simulate our heat transfer equation. Let's print some additional
useful information at the end of the program:

~~~
// Print final information
writeln('\nFinal temperature at x = ', x, ', y = ', y, ' after ', c,
        ' iterations is: ', temperature[x,y]);
writeln('The largest difference in temperatures between ',
        'the last two iterations was: ',
        current_diff, '\n');
~~~
{: .source}

and compile and execute our final code,

```
>> chpl base_solution.chpl -o base_solution
>> ./base_solution
```
{: .input}

~~~
This simulation will consider a matrix of 100 by 100 elements.
We will look at the temperature at the location x = 1, y = 1.
We will run up to 500 iterations, or until the largest difference in temperature between iterations is less than 0.0001.

Temperature at start is: 25.0
Temperature at iteration 20: 1.48171
Temperature at iteration 40: 0.767179
Temperature at iteration 60: 0.517628
Temperature at iteration 80: 0.390586
Temperature at iteration 100: 0.313617
Temperature at iteration 120: 0.26199
Temperature at iteration 140: 0.224958
Temperature at iteration 160: 0.197099
Temperature at iteration 180: 0.175379
Temperature at iteration 200: 0.157972
Temperature at iteration 220: 0.143708
Temperature at iteration 240: 0.131806
Temperature at iteration 260: 0.121725
Temperature at iteration 280: 0.113077
Temperature at iteration 300: 0.105576
Temperature at iteration 320: 0.0990081
Temperature at iteration 340: 0.0932096
Temperature at iteration 360: 0.0880528
Temperature at iteration 380: 0.0834366
Temperature at iteration 400: 0.0792804
Temperature at iteration 420: 0.0755185
Temperature at iteration 440: 0.0720975
Temperature at iteration 460: 0.068973
Temperature at iteration 480: 0.0661081
Temperature at iteration 500: 0.0634717

Final temperature at x = 1, y = 1 after 500 iterations is: 0.0634717
The largest difference in temperatures between the last two iterations was: 0.0180001
~~~
{: .output}

Note: for the example above, the solution still has not
converged after 500 iterations.

{% include links.md %}
